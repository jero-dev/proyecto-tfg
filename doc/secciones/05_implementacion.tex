\chapter{Implementación}

Como llegamos a mencionar en la implementación de planificación, el proyecto se ha 
dividido en varios hitos o Milestones (se les puede echar un vistazo en la 
\href{https://github.com/jero-dev/proyecto-tfg/milestones}{página del repositorio 
en GitHub}) en el que vamos a concentrar las distintas tareas que debemos de 
realizar para completar cada uno de ellos.

También habiendo hecho el análisis del problema mediante diseño dirigido por 
dominios, hemos podido dividir en tres los servicios de dominio para finalmente 
obtener nuestro producto mínimo viable. Estos serían:

\begin{itemize}
    \item \textbf{Obtención de información:} Necesitamos obtener las ofertas desde 
    los canales y servidores que podemos encontrar en Telegram y Discord 
    respectivamente.
    \item \textbf{Gestión de productos:} Necesitamos almacenar los productos que 
    los usuarios buscarán también.
    \item \textbf{Gestión de ofertas:} Necesitamos almacenar las ofertas que 
    dependerán del producto y la tienda. También queremos saber si la oferta está
    todavía vigente o no.
\end{itemize}

Con esto en mente, empecemos con el desarrollo del proyecto.

\section{Obtención de información}

Primero, debemos de tener información de las ofertas. Como llegamos a mencionar en 
capítulos anteriores, podemos llegar a encontrarlas en canales de Telegram y en 
servidores de Discord. Ahora, ¿cómo podemos llegar a automatizar la obtención de 
esa información? Pues utilizando algo que tienen en común ambos servicios: los bots.

Los bots son muy populares tanto en Telegram como en Discord. Las comunidades de 
los dos servicios los usan para automatizar mensajes de bienvenida o procesos de 
autenticación al llegar a un nuevo servidor o grupo, llegando a preguntar que le 
llegó a interesar al usuario acerca de la comunidad a la que se está uniendo o 
simplemente enviar un emoji, para así poder comprobar que no es otro bot pero con 
intenciones de realizar spam o cualquier otra actividad maliciosa.

Ahora, ¿cómo se crea un bot? Para ambos casos existe una API pública con la que 
podemos interactuar y llegar a automatizar los procesos que queramos. Para ello 
necesitaremos entonces implementar dos programas (uno para cada uno de los 
servicios) que recibirán y leerán los mensajes de los distintos canales y 
servidores.

Estos programas los escribiremos con el lenguaje de programación Go, ya que, como 
llegamos a analizar en el capítulo acerca del estado del arte, es un lenguaje que 
cumple con las categorías que llegamos a enunciar. Además, necesitaremos desplegar 
los programas resultantes para que estén accesibles y para ello usaremos Azure 
como plataforma donde alojarlos, siendo un servicio de \textit{cloud computing} 
que es muy empleado a nivel profesional y que cuenta con un programa para 
estudiantes que nos permite utilizarlo de forma gratuita.

A partir de aquí, vamos a separar el desarrollo en dos partes: cómo obtenemos la 
información desde Telegram y cómo lo hacemos desde Discord.

\subsection{Obtención de información en Telegram}

Para crear nuestro bot de Telegram, necesitaremos seguir los pasos documentados en 
el \href{https://core.telegram.org/bots#how-do-i-create-a-bot}{sitio oficial} para 
tener la infraestructura lista antes de empezar a programar.

Habiendo seguido los pasos necesarios que vienen en la documentación, empezamos a 
programar nuestro bot.

Como comentamos en el capítulo del estado del arte \ref{chapter:02_estado_del_arte}, 
cada lenguaje cuenta con una librería para interactuar con la API de bots de 
Telegram. En nuestro caso, hemos empleado una de las que hay para Go que es la más 
extendida (puede encontrarse 
\href{https://pkg.go.dev/github.com/go-telegram-bot-api/telegram-bot-api/v5}{aquí}) 
que nos ofrece todo lo necesario.

En este caso, lo único que queremos es obtener la información. No la vamos a darle 
formato o encontrar la información que nos interesa, ya que de eso se encargará el 
programa principal que haremos más adelante. Así que, lo que realmente hará es 
obtener cualquier mensaje que reciba de cualquier tipo de chat en el que se 
encuentre (aunque en el código se debe de diferenciar si es un canal o si es un 
grupo) y enviarlo a nuestro servicio principal.

El código resultante de la implementación no es muy extenso, pero realiza todas las 
actividades que requerimos. Para acceder al código, se puede ir mediante 
\href{https://github.com/jero-dev/proyecto-tfg/blob/main/src/bot/telegram/main.go}{este enlace}.

Lo que hemos creado es una API que tiene dos rutas: una por donde recibir los 
mensajes y otra que configure la primera como un webhook para la API de Telegram. 
El porqué de esto es simple: según la documentación, podemos comprobar las 
actualizaciones que nos llegan desde la API de Telegram de dos maneras. Una de 
ellas requiere estar revisando constantemente dentro de un bucle si obtenemos 
una actualización o no, mientras que el otro método es configurar una ruta a la que 
la API lanzará automáticamente las actualizaciones.

Como se puede observar, esto último es mucho más eficiente, ya que aunque recibamos 
mensajes constantemente,  si siguiéramos el primer método el programa estaría 
ejecutando un bucle infinito que consume recursos, mientras que con la indicación 
de ruta es simplemente quedarse escuchando por un puerto.

Además, en la implementación de nuestro \textit{workflow} 
tenemos no solamente nuestra comprobación de CI, sino que hemos añadido también el 
despliegue automático del bot en Azure, haciendo que cada vez que se añadan cambios 
de funcionalidad en el bot, estos sean desplegados sin tener que hacer ninguna 
acción por nuestra parte. Si se quiere revisar el código de la automatización, se 
puede seguir 
\href{https://github.com/jero-dev/proyecto-tfg/blob/main/.github/workflows/bot-telegram-ci.yml}{este otro enlace}.
